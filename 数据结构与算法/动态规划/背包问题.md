# 背包问题

## 01背包

$n$ 物品数量， $v$ 背包容量， $c_i$体积， $w_i$价值。每种物品只有一个。

求背包最大价值。

$dp[i][v]=\max(dp[i-1][v],dp[i-1][v-c[i]]+w[i])$

这个东西显然可以压维

$dp[v] = \max(dp[v],dp[v-c[i]]+w[i])$

$v$ 要从 $v$ 枚举到 $c[i]$（从大到小）， 这可以保证 **只放1个第$i$个物品**。

复杂度 $O(nv)$ 。



## 完全背包

每种物品有无限个。

$dp[i][v]=\max(dp[i-1][v],dp[i-1][v-k*c[i]]+k*w[i])$

考虑每次决策只放假想的**每种物品的最后一个**，因为一种物品可以取 $0\sim \infty$ 个，所以有两种情况：

- 没选第 $i$ 个物品，前 $i-1$ 个物品所占容量达到 $v$
- 选了第 $i$ 个物品，但是不管它选了几个，我们只考虑放最后一个该种物品的情况

$dp[i][v]=\max(dp[i-1][v],dp[i][v-c[i]]+w[i])$

这个方程也只涉及 $i$ 和 $i-1$ 的转移，可以压维。

$dp[i][v]=\max(dp[i-1][v],dp[v-c[i]+w[i]])$

这个东西跟01背包的转移方程一模一样，但是**$v$的枚举顺序不同**，这是因为在考虑放第 $i$ 个物品时，存在一个是否允许它前面有数个该种物品的问题。注意一个关键点，当我们把01和完全背包的转移方程压维成 $dp[v]=\max(dp[v],dp[v-c[i]]+w[i])$ 时，隐含的条件是**当前放的物品一定是第$i$个物品中的最后一个**。

从后往前枚举 $v$， 虽然不考虑现在放的第$i$个物品后面放了什么，但根据定义这意味着我们放的这个第 $i$ 个物品永远**是最后一个该种物品**， 从前往后则不然。

复杂度 $O(nv)$ 。



## 多重背包

每种物品有 $k_i$ 个。

裸转移方程跟完全背包差不多：

$dp[i][v]=\max(dp[i-1][v],dp[i-1][v-k*c[i]]+k*w[i])~k\in[0,k_i]$

多重背包不能用完全背包的方式压维，因为完全背包在放第 $i$ 种物品的最后一个时不必考虑它前面放了几个该种物品，但是多重背包需要考虑。一般来说，由于 $k_i$ 确定，于是可以将所有物品解组，变成总共 $n*\sum_i k_i$ 个物品，转换成01背包解。

复杂度 $O(nk*\sum_i k_i)$

可采取两种方式优化。

### 二进制分组

令$2^m<=k_i<2^{m+1}$

分解$k_i=2^0+2^1+2^2\cdots+2^{m-1}+(k_i-2^m)$

将每种物品根据如上方法解组，把每 $2^j$ 个第 $i$  种物品重组，再用01背包。注意，重组物品后，若我们要在第 $i$ 种物品中选 $d_i$ 个，也用上述方法去组合即可。

复杂度 $O(nv*\sum log_2k_i)$ 。

#### Code

```c++
for(int i=1;i<=n;i++) {
        int w_n[21] = {0}, v_n[21] = {0};
        int cnt = 0;
        for(int j=1;d[i]>j;d[i]-=j, j<<=1)                 //二进制拆分
            w_n[++cnt] = j * w[i], v_n[cnt] = j * v[i];

        w_n[++cnt] = d[i] * w[i], v_n[cnt] = d[i] * v[i];

        for(int k=1;k<=cnt;k++)
            for(int j=V;j>=v_n[k];j--) 
                dp[j] = max(dp[j], dp[j - v_n[k]] + w_n[k]);
    }
```



## 混合背包

01背包、完全背包和多重背包的混合。

枚举 $i$ 种物品，根据该种物品类型使用不同转移方程即可。

伪代码：

```c++
for i = 1 to n
	if 01
		for j = v to 0
	if 完全
		for j = 0 to v
	if 多重
		二进制分解
		for j = 1 to m
			for k = v to 0
```



## 分组背包

将 $n$ 个不同的物品分为 $k$ 个组，每个组至多只能选一个。

一个显然的思路是，可以把这 $k$ 个组看作 $k$ 种物品， 然后对这绑在一起的 $k$ 种物品做01背包。对于每组内的【至多选择一个物品】的限制，可以通过改变控制**循环顺序**约束。

伪代码：

```c++
for t = 1 to k
	for j = 0 to v
		for i in group_t
			dp[j] = min(dp[j], dp[j - c[i]] + w[i])
```

可以看到，我们把**容量**和**物品序号**的循环层次调换了，这就保证了对于一个可能达到的容量 $j$ ， 第 $t$ 组的物品我们只放一个。



## 二维背包

选一个物品有两种开销（原来只有一种开销，即体积）的01背包。

另一种开销多记一维即可，显然正确。

转移方程

$dp[i][j]=\max(dp[i][j],dp[i-c_1[i]][j-c_2[i]]+w[i])$



## 有依赖的背包



P1782 P1941 P2170 P2758 P1063 P1220 P4170 P2466 P1833

dp_e dp_k dp_l