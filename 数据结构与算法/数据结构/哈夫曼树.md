# 哈夫曼树

## 写在前面

考虑这样一个问题：将一个字符串编码成二进制序列，为了传输的经济划算，我们希望这个序列尽可能短，并且能够具有唯一译码结果。

* 哈夫曼树其实就是用来做这种编码的，因为它确实做到了最短且唯一，有时候用来无损压缩（HTTP2）。
* 哈夫曼树由于其优秀的性质得名最优树。

## 哈夫曼编码

哈夫曼编码是一种可变字长编码方式，具体来说，**字符出现的频率越高，编码一个这种字符占用的字节越少**。此外，哈夫曼编码还是一种前缀编码，即**任意字符的编码都不是其他字符的编码的前缀**。

> 注：哈夫曼编码与字符出现的频率有关，这意味着它对每个不同字符串都是唯一的。

哈夫曼编码一般用哈夫曼树来表达，对于字符串 $ABACCDA$， 哈夫曼树和哈夫曼编码的对应关系如下。

![Screenshot-from-2022-10-04-22-21-20.png](http://image.tjzfile.xyz/images/2022/10/04/Screenshot-from-2022-10-04-22-21-20.png)

* 可以看到，构造好哈夫曼树后，每个字符的编码就是根节点到叶子（字符）的路径上的节点组成的二进制串。而译码时，就从根节点开始，遇到 $0$ 则在哈夫曼树上走向左子树，否则走向右子树。
* 观察发现，（1）出现频率越高的字符深度越浅，编码串长越短。（2）所有字符都在叶子节点，且节点值为 $0$。

这种编码方式使得**哈夫曼编码为前缀编码**，因为这些字符前缀 $1$ 的数量都不一样，这保证了译码的唯一性。

此外，这种编码方式将使得编码后的字符串总长最短，由于这算法本质上是贪心，所以可以用反证法证明。

> 首先，设任意叶子节点 $i$ 的权值为其在串中出现频次，记为 $w_i$，从根节点到叶子节点的路径长度即该字符编码串长度，记为 $l_i$。那么我们实际上希望最小化
> $$
S = \sum_{i = 1}^{n} w_il_i
$$
> 
> 这意味着哈夫曼树的构造是一种自然的结论。现在假设哈夫曼编码不是最短编码方式，那么存在一个深度较深的叶子节点，它替换一个较浅的叶子节点后 $S$ 将减小。而我们替换后将发现这一操作一定会使得 $S$ 增大。

## 哈夫曼树

上文简要叙述了哈夫曼编码的原理，但是尚未给出这种编码的产生方式。哈夫曼树的构造将解决这一点。

* 哈夫曼树构造算法是一个简单的贪心，它先将所有字符结点作为单独的树，然后每次选取根节点权值最小的两颗树进行合并。
* 合并是这样一种操作，它把两颗子树的根节点连向一个新的根节点，构造一个新的树，这个新树的根节点的权值是两子树根节点权值之和。注意，这个树将是二叉树。
* 重复以上步骤直到森林中只有一棵树。

![Screenshot-from-2022-10-04-22-58-48.png](http://image.tjzfile.xyz/images/2022/10/04/Screenshot-from-2022-10-04-22-58-48.png)

