---

mindmap-plugin: basic

---

# UDP-TCP

## UDP
- 缺点
  - 丢包
  - 无序
- 特性
  - 无握手
  - 各段处理相互独立
- 使用原因
  - 无连接
  - 首部短
  - 无拥塞控制
- UDP 可靠传输：在应用层增加可靠性，添加差错恢复
- UDP 报文段格式
- UDP 检验和
  - 发送
    - 将数据的每两个字节当作一个16 位的整数
    - 求和，最高位进位回加到结果
    - 逐位取反，作为最终检查和
  - 接收
    - 按与发送同法对数据求和
    - 再与检查和求和
    - 结果全 1 则无差错，有 0 则有差错

## 可靠数据传输
- 实现：FSM 有限状态机
- 经可靠信道上的可靠数据传输 rdt1.0
  - 假设
    - 底层信道完全可靠
    - 收发双方速率匹配
  - 特性
    - 所有的分组都是从发送方流向接收方
    - 接收方不需反馈信息给发送方，因为不会发生任何差错
  - ![IMG_0484.jpg](http://image.tjzfile.xyz/images/2023/04/04/IMG_0484.jpg)
- 具有比特差错信道上的可靠数据传输 rdt2.0
  - 假设
    - 信道可能产生比特差错，但不丢包
    - 所有分组按发送顺序接收
  - 解决方案：自动重传请求协议 ARQ
    - 差错检测
      - 使接收方检测出是否出现比特差错
      - 增加检验和字段
    - 接收方反馈
      - 使发送方知道发送的分组是否被正确接收
      - ACK/NAK：正确接收/有误
    - 重传：有差错就通知发送方重传
  - 缺陷：若返回的ACK或NAK分组受损，发送方无法知道接收方是否正确接收了上一块数据
  - ![IMG_0485.jpg](http://image.tjzfile.xyz/images/2023/04/04/IMG_0485.jpg)
  - 处理受损 ACK/ NAK：重发数据分组
    - 问题：产生冗余分组，同一个分组收到两次
    - 解决：给分组添加序号字段，序号相同则为重复分组
    - 序号位数选择：只需用一个比特，即“0”和“1”两种不同的序号，序号通过模2运算向前移动
- FSM rdt2.1
  - 特性
    - 可处理重复分组
    - 分别处理 0，1 号分组
  - 说明
    - ACK和NAK分组不需要指明要确认的序号，因为假设信道不丢失分组
    - 发送方知道所接收的ACK和NAK分组是对最近发送分组的响应
  - ![IMG_0495.jpg](http://image.tjzfile.xyz/images/2023/04/11/IMG_0495.jpg)
  - ![IMG_0496.jpg](http://image.tjzfile.xyz/images/2023/04/11/IMG_0496.jpg)
- rdt 2.2
  - 改进 2.1，状态压缩为只有 ACK 0, ACK 1
  - 接收方收到受损的分组时，丢弃，不发送NAK，改为发送一个前一个正确接收分组序号的ACK
  - 若接收冗余 ACK，可知发生错误
- rdt 3.0
  - 假设
    - 比特差错
    - 丢包
  - 丢包处理策略
    - 超时重发
    - 时间选择
    - 冗余分组
  - 重传实现策略
    - 倒计时器，给定时间过期后中断发送方
  - ![IMG_0498.jpg](http://image.tjzfile.xyz/images/2023/04/11/IMG_0498.jpg)
- 停等协议的性能
  - 利用率：$\dfrac{L/R}{RTT + L/R}$
  - 一次发一个，等待响应，若 RTT 太大，效率很低

## 流水线可靠数据传输协议
- 动机：停等协议效率太低（在传播时延 RTT 过大时）
- 分类
  - GBN
    - 连续发送多个分组，每个分组有唯一序号
    - 发送方和接收方需要缓存多个分组
      - 发送方缓存已发送未ACK分组
        - 接收方缓存正确接受的分组
    - 发送方：连续发送多个数据分组
      - 收到 ACK，继续发送
      - 超时，**从出错分组开始重发后面的**
    - 接收方：按序号接收数据分组
      - 正确：接收，发ACK
      - 错误：丢弃该分组及后面所有分组，不发应答
    - 特性
      - 连续发送的分组个数不能太多
      - 不允许超过 N 个
      - 解决：设置发送、接收窗口
  - 改进 GBN
    - 滑动窗口
      - 已确认
      - 已发未确认
      - 准备发送
      - 不能发送
    - 缺点：可能需要很多重传
    - 窗口最大尺寸：若序号位数 $k$，则最大尺寸 $2^k - 1$
    - 发送方扩展 FSM：基于ACK
      - 上层调用
        - 窗口满：将数据返回上层，以后再试
        - 窗口未满：发送分组
      - 收到 ACK
        - 累积确认，表明该ACK前的分组都被接受
      - 超时
        - 只使用一个计时器，作为最早的已发送但未被确认的分组的定时
        - 产生超时，发送方重发所有已发送过但还未被确认过的分组
        - 收到一个ACK，但仍有已发送但未被确认的分组，重新启动定时器。若没有未确认报文，终止定时器
    - 接收方
      - 按序接收，窗口大小 $1$
      - 情况
        - 按序接收到分组 $n$：将该分组数据交付到上层，回发 ACK n。
        - 其他情况分组：丢弃该分组，并为**最近按序接收的**分组重发ACK。
      - 特点
        - 分组一次性交付给上层：分组 k 被交付， k之前均已交付。
        - 丢弃所有失序分组：控制简单，接收方不需要缓存任何失序分。
  - 选择性重传
    - **接收方窗口大小大于 1**
    - 窗口最大尺寸（序号位数 $k$）
      - 接收方：$2^{k-1}$
      - 发送方：$2^{k-1}$
    - 思路：将正确接收的分组缓存，只对出错的分组进行重传
    - 发送方
      - 收到 ACK，继续发送后面的分组（？）
      - 超时：只重发错误分组，窗口内每个分组都有一个计时器，超时重传
      - 从上层收到数据：当从上层接收到数据后，发送方检查下一个可用于该分组的序号
        - 若序号在发送方窗口内，则将数据打包并发送
        - 否则与GBN一样，将数据缓存，或将其返回给上层，以后再传
      - 收到ACK：将被确认的分组标记为已接收(若该分组序号在窗口内)
        - 如果该分组的序号等于发送基序号send_base，则窗口基序号向前移动到具最小序号的未确认分组处
        - 窗口移动后，仍有序号落在窗口内的未发送分组，继续发送
    - 接收方
      - 正确：接收、并交付，发确认ACK，无论是否有序。
      - 出错：失序分组先被缓存，直到所有丢失分组（序号更小的分组）被收到为止，才可将一批分组按序交付给上层。
      - 序号在接收窗口内的分组被正确接收：收到的分组落在[rcv_base， rcv_base+N-1]内，接收并回发一个ACK。
        - 如果该分组以前没收到过，则被缓存
        - 如果该分组的序号等于接收基序号，则该分组及已缓存的序号连续的分组交付（起始于基序号）给上层。然后，接收窗口按交付的分组数量向前移动
      - 收到序号在接收基序号以前的分组
        - 该分组是接收方以前已确认过的分组。生成一个ACK，并回发给发送方
        - 如果接收方不确认，发送方窗口不能向前滑动
      - 其他情况：忽略该分组
  - 总结

## TCP
- TCP 序号和确认号
  - 序号 Seq：报文段第一个数据字节在字节流中的位置编号（一个报文段有多个字节）
  - 确认号 ACK：期望从对方收到下一个字节的序号
- 拥塞控制
  - 方法
    - 端到端拥塞控制：端系统必须通过对网络行为的观察 (如分组丢失与时延)来推断网络中是否存在拥塞。
    - 网络辅助的拥塞控制：网络层构件 (即路由器)向发送方提供关于网络拥塞状态的明确反馈信息（一个比特）
  - 拥塞信息反馈方式
    - 直接反馈：路由器直接通过阻塞分组告知发送方
    - 经接收方的反馈：路由器表示拥塞，当接收方收到有拥塞标记的分组后，就通知发送方网络发生了拥塞
  - ATM ABR拥塞控制
    - ATM异步传输模式
      - 面向连接的分组交换技术
      - 采用虚电路VC
    - ABR可用比特率
      - 轻载利用空闲带宽
      - 拥塞抑制速率
    - 基于速率的方法
      - 明确计算最大发送速率
  - TCP拥塞控制
    - 端到端控制（没有网络辅助）
    - 发送方感知
      - 有拥塞：降速
      - 无拥塞：增速
  - 限制发送速率
    - 设置拥塞窗口 cwind：对发送方向网络的发 送流量速率进行限制
    - 调节 cwind 值，调整发送速率
  - 感知网络拥塞
    - 丢包：超时或者 3个重复ACK
    - 丢包后降低速率
  - 解决
    - 加增倍减算法（AIMD）：不拥塞 cwind+1，否则/2
    - 慢启动：不拥塞 cwind * 2，否则=1
    - 超时事件后的保守机制
      - 初始慢启动，超过阈值转为AIMD，丢包后策略不同
      - RENO：阈值降低一半，从阈值开始AIMD
      - Tahoe：阈值降低一半，从1开始慢启动到阈值再AIMD