# 动态内存分配

## 动态内存申请

* C风格

```cpp
a = (int *)malloc(sizeof(int))
b[N] = (int *)malloc(sizeof(int) * N)
```

* C++风格

```cpp
a = new int;
b[N] = new int[N];
```

## 动态内存释放

* C风格
  
```cpp
free(a);
for(int i = 0; i < N; i++) free(a[i]);
```

* C++风格

```cpp
delete a;
delete [] b;
```

> 注：`new` 变量和数组必须和 `delete` 变量和数组一一对应，比如 `new a, delete [] a` 是不允许的。

## 内存安全

### 内存泄漏

* 当程序向操作系统申请了内存却未及时释放，则有可能造成内存泄漏。

解决办法也很简单，只要在每个需要的地方及时 `free` 掉不用的动态内存空间即可（虽然在大型项目中可能难以发现）。

### 内存重复释放

* 潜在的重复释放同一块内存空间的风险，有可能会导致段错误，有时甚至导致更为严重的结果，因为它的风险是不确定的，我们无法确知已经被释放的内存空间现在在干什么。

对于类中可能的此种风险，解决方法是[深拷贝](../指针/指针补充.md#悬挂指针)，简单来说就是

对于其他情况来说，一般不常见（注意上面链接的第二种情况不属于内存重复释放的例子），因为基本上不会这样写。