# 指针及其特性

> 因为在 C 中已经学过所以这篇主要是记录一些（我不知道的）新特性和要点。

## 常指针

* 常指针分为指向常量的指针和指针类型的常量。

常量的指针： `const int *ptr = &data`，指针（指向的地址）可变而指针指向的数据不可变。

比如 `*ptr = 3` 是不被允许的，但 `ptr = &data_1` 是允许的。

指针类型的常量： `int const *ptr = &data`，指针不可变而指针指向的数据可变。

比如 `*ptr = 3` 是允许的，`ptr = &data_1` 是不允许的。

> 注：实际上数组名是一个指针类型的常量。

## 空指针、悬挂指针和野指针

### 空指针

参考了[这篇文章](https://blog.csdn.net/sandalphon4869/article/details/89166458)。

在 C++ 中，空指针被定义为 `NULL`，实际上它是 0 的别名。这种定义在 C++ 中存在风险（如在重载函数中被识别为整型而导致意料之外的结果），因此 C++ 更推荐使用具有保护的 `nullptr`，比如 `int *ptr = nullptr`。

> 注：
> （1）在 C 中，空指针 `NULL` 被定义为 `(void *)0`，但是 C++ 禁止了这种做法而将其定义为 0，这是因为 C++ 中 `(void *)` 类型的指针不能解引用，也不能隐式地转换为别的类型的指针。比如 `int *ptr = (void *)0` 就是被禁止的。
> （2）`NULL` 或 0 地址是不可访问和更改的，还有一些具有特殊用途的内存地址也是不可访问的。

### 悬挂指针

参考了[这篇文章](https://www.cnblogs.com/idorax/p/6475941.html)。

* 指向已经被回收的内存空间的指针。

（1）拷贝构造函数

在类的[拷贝构造函数](./../类与对象/类与对象.md#拷贝构造函数)中，提到的悬挂指针问题就是由于可能存在的多次释放同一内存空间的隐患导致的。

解决这个问题的办法就是在拷贝构造函数里为每个新复制的实例都申请一块新的动态内存空间（深拷贝），这样就不会造成多个指针指向同一个内存地址的问题了。

（2）指针型函数

如果指针操作超越了变量的作用域，也会导致悬挂指针，因为在作用域外这个指针指向的静态内存空间已经被释放。指针型函数是一个很好的例子。

```cpp
int *foo(int i) {
    int a = 0;
    return &a;
}
```

此时返回的就是一个悬挂指针，因为函数返回时 `a` 已经被销毁。

但是指向动态内存空间的指针是可以返回的，只要不手动 `free` 掉这块内存它就不会被销毁。不过既然如此那么就要记得及时释放内存，避免内存泄漏。

```cpp
int *foo(int i) {
    int a = 0;
    int *p = new int;
    *p = a;
    return p;
}
```

（3）更一般的情况

如果 `free` 或 `delete` 掉指针 `ptr` 指向的内存空间之后，`ptr` 还在其生存周期内，那么 `ptr` 此时就是悬挂指针，因为它仍然指向这块已经被回收的（不可利用的）内存空间。此时再去操作这个指针指向的内容将导致不可预料的结果。

```cpp
int main()
{
    // ... do something
    char *p = new char[11];
    strcpy(p, "make sysu");
    free(p);
    strcpy(p, "great again");
    return 0;
}
```

> 注意：这段代码是可以运行的，编译器不会报错，但是存在极大的内存安全隐患，因为它试图对已经回收的内存地址写入数据，而这块地址可能是已经被使用了的。

解决这个问题的办法是在 `free` 或者 `delete` 后马上 `ptr = nullptr`，要用的时候再申请动态内存。

### 野指针

* 未初始化的指针，指向未知的内存空间，这时对指针指向的数据进行操作可能导致程序崩溃。

解决方法就是记得每次初始化的时候统一赋一个空指针，就没事了。

> 注： 声明为全局变量的指针会被初始化为 `NULL`。

## 函数指针和指针函数

### 指针型函数

* 返回值是指针的函数，声明形式形如 `int *func(int i)`。

这个东西好像没有太大的用处，也就嗯写 `char *` 字符串用用？不太清楚，但是这东西似乎隐患比优势更多，因为会导致各种内存错误。

### 函数指针

* 指向函数的指针，适用于各种泛型和代码复用，可以被理解为代码中的可替换插件/模组。
* 函数指针的声明形式跟指针型函数很像，只是多了个括号，比如 `int (func *)(int i)`。
* 函数指针可以作为函数参数，它可以被理解为传入函数的别名。

举一个机器学习的例子，在各种高级API中可以看到向函数传入不同的损失/激活函数的指针作为参数的情况，这在减少代码重用的同时极大的增强了可扩展性。

> 注：
> （1）认为函数指针是指向函数的指针是不准确的，确切的说它应该是指向函数对应代码段在内存中所在地址的指针。
> （2）函数名其实就是一个常量函数指针。

## 对象指针

### 指向实例化对象的指针

* 指向实例化对象的指针需要用对象的类名声明，它指向该对象的内存地址。

```cpp
Point pt;
Point *p = &pt;
```

> 注：实例化对象所占据的内存空间只用于存放数据成员，函数成员不在每一个对象中存储副本。

#### 拓展：类间通信

* 类间通信除了用全局变量和静态类成员变量来实现，还可以用对象指针实现。

定义这样的两个类 $A, B$

```cpp
class B; // 前向引用声明
class A {
public:
    ...
private:
    int data;
    B *pt;
};

class B {
public:
    ...
private:
    int data;
    A *pt;
};

int main() // 当然，这一方法不限于主函数
{
    ...
    A a; B b;
    a.pt = &b;
    b.pt = &a;
}
```

> 注：
> （1）前向引用声明是必须的，因为 $B$ 在 $A$ 之后定义。
> （2）可以通过在 $A$ 的方法中调用 $B$ 的实例或反之来实现类间通信和数据传输。

### 指向类的非静态成员的指针

* 这个东西好像没有什么用。

```cpp
int Point::*ptr;
int (Point::*funcptr)(args);

ptr = &Point::data;
funcptr = &Point::function;

Point a;
a.*ptr = data;
(a.*funcptr)(args);
```

> 注：
> （1）类在声明时不进行内存分配，只有在实例化时才进行内存分配，因此为指向类的非静态成员的指针进行赋值时必须指定特定的对象。
> （2）常成员函数与普通成员函数具有不同的类型，在定义能够被常成员函数赋值的指针时必须添加 `const` 关键字。

### 指向类的静态成员的指针

* 由于类的静态成员不依赖于对象，所以可以以一般的方式定义指向它的指针。

```cpp
int *ptr = &Point::staticdata;
int *funcptr = &Point::staticfuction;
```

## void 指针

* `void` 指针是泛型编程的优秀语言工具，它是一种未被预先定义类型从而可以在定义后指向任意数据类型的指针。

```cpp
void *p;
int a;
float b;
char c;
p = &a;
p = &b;
p = &c;
```

但是必须注意，`void` 指针**不能直接转换成其它类型的指针，也不能直接解引用**，正确的做法是先进行强制类型转换再操作。

```cpp
int data;
void *p = &data;
cout << *((int *)p) << *(static_cast<int *>(p))<< endl;
```